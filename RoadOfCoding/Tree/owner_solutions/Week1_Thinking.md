## 102. Binary Tree Level Order Traversal 反思
- 在v1_102.js中我完全主打的是**樹的性質**，我優先注意到了指定某k層(深度為k)的時候，單層的滿節點個數為2^(k-1)。
- 這種完全基於性質上的解法在一些例子中遇到了問題：
    - case: [3,9,20,null,null,15,7]
    - 經過討論與反思後，實際上主因是因為v1對於null的節點並不會加入，這導致null並不被視為同層中的節點，使得剩餘的節點只要不是滿層就不會被加入。
    - 不必在苦思這個修訂方案了，因為實際上都不v2_102所使用的方法，如果真的要去記錄前置節點，這將導致邏輯上的混亂，混亂的邏輯且不具備效益，故我個人認為最佳解法大概是發生在v2，至少已可讀性而言都有更好的可讀空間與可維護空間。
- 在v2_102.js中這個思路非常的無暇，它的想法是，滿層節點個數2^(k-1)的結論這只是一種結論，它是因為樹的性質而擁有該結論。故它真正意義上的實現了BFS，也就是完全依照BFS的流程走。
## 94. Binary Tree Inorder Traversal
- 這題比較沒有懷疑的空間，因為中序搜尋本來就是遵循者**左->中->右**的順序進行遍歷。

## 589. N-ary Tree Preorder Traversal
- 細細的品味題目，他使用的children竟然是一個array，這個有點意思。這似乎是一種挺實用的資料結構？雖然我暫且想不到應用在哪裡，但這似乎翻轉我對樹狀結構的印象。
